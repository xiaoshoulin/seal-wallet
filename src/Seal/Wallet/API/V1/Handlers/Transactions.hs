{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TypeOperators     #-}

module Seal.Wallet.API.V1.Handlers.Transactions (
      handlers
    , newTransaction
    , getTransactionsHistory
    , estimateFees
    -- | Helper converter.
    , txFromMeta
    ) where

import           Universum

import           Servant

import           Seal.Client.Txp.Util (defaultInputSelectionPolicy)
import           Seal.Chain.Genesis
import           Seal.Wallet.API.Request
import           Seal.Wallet.API.Response
import qualified Seal.Wallet.API.V1.Transactions as Transactions
import           Seal.Wallet.API.V1.Types
import           Seal.Wallet.Kernel.CoinSelection.FromGeneric
                     (ExpenseRegulation (..))
import           Seal.Wallet.Kernel.DB.HdWallet (UnknownHdAccount)
import           Seal.Wallet.Kernel.DB.TxMeta (TxMeta)
import           Seal.Wallet.WalletLayer (ActiveWalletLayer,
                     NewPaymentError (..), PassiveWalletLayer)
import qualified Seal.Wallet.WalletLayer as WalletLayer
import           Seal.Wallet.WalletLayer.Kernel.Conv (toInputGrouping)

handlers :: ActiveWalletLayer IO
         -> Config
         -> ServerT Transactions.API Handler
handlers aw config = newTransaction aw config
         :<|> getTransactionsHistory (WalletLayer.walletPassiveLayer aw)
         :<|> estimateFees aw
         :<|> newUnsignedTransaction aw
         :<|> submitSignedTransaction aw

-- | Given a 'Payment' as input, tries to generate a new 'Transaction', submitting
-- it to the network eventually.
newTransaction :: ActiveWalletLayer IO
               -> Config
               -> Payment
               -> Handler (APIResponse Transaction)
newTransaction aw configurable payment@Payment{..} = liftIO $ do

    -- NOTE(adn) The 'SenderPaysFee' option will become configurable as part
    -- of CBR-291.
    let inputGrouping = toInputGrouping $ fromMaybe (WalletInputSelectionPolicy defaultInputSelectionPolicy)
                                                    pmtGroupingPolicy
    res <- liftIO $ (WalletLayer.pay aw) configurable inputGrouping SenderPaysFee payment
    case res of
         Left err        -> throwM err
         Right (_, meta) -> txFromMeta aw NewPaymentUnknownAccountId meta

txFromMeta :: Exception e
           => ActiveWalletLayer IO
           -> (UnknownHdAccount -> e)
           -> TxMeta
           -> IO (APIResponse Transaction)
txFromMeta aw embedErr meta = do
    mTx <- WalletLayer.getTxFromMeta (WalletLayer.walletPassiveLayer aw) meta
    case mTx of
      Left err -> throwM (embedErr err)
      Right tx -> return $ single tx

getTransactionsHistory :: PassiveWalletLayer IO
                       -> Maybe WalletId
                       -> Maybe AccountIndex
                       -> Maybe WalAddress
                       -> RequestParams
                       -> FilterOperations '[WalletTxId, WalletTimestamp] Transaction
                       -> SortOperations Transaction
                       -> Handler (APIResponse [Transaction])
getTransactionsHistory pw mwalletId mAccIdx mAddr requestParams fops sops =
    liftIO $ do
        mRes <- WalletLayer.getTransactions pw mwalletId mAccIdx mAddr requestParams fops sops
        case mRes of
            Left err  -> throwM err
            Right res -> return res

-- | Computes the fees generated by this payment, without actually sending
-- the transaction to the network.
estimateFees :: ActiveWalletLayer IO
             -> Payment
             -> Handler (APIResponse EstimatedFees)
estimateFees aw payment@Payment{..} = do
    let inputGrouping = toInputGrouping $ fromMaybe (WalletInputSelectionPolicy defaultInputSelectionPolicy)
                                                    pmtGroupingPolicy
    res <- liftIO $ (WalletLayer.estimateFees aw) inputGrouping
                                                  SenderPaysFee
                                                  payment
    case res of
         Left err  -> throwM err
         Right fee -> return $ single (EstimatedFees (WalletCoin fee))

-- | Creates new unsigned transaction.
--
-- NOTE: This function does /not/ perform a payment, it just prepares raw
-- transaction which will be signed and submitted to the blockchain later.
newUnsignedTransaction :: ActiveWalletLayer IO
                       -> Payment
                       -> Handler (APIResponse UnsignedTransaction)
newUnsignedTransaction aw payment@Payment{..} = do
    let inputGrouping = toInputGrouping $ fromMaybe (WalletInputSelectionPolicy defaultInputSelectionPolicy)
                                                    pmtGroupingPolicy
    res <- liftIO $ (WalletLayer.createUnsignedTx aw) inputGrouping
                                                      SenderPaysFee
                                                      payment
    case res of
        Left err         -> throwM err
        Right unsignedTx -> return $ single unsignedTx

-- | Submits externally-signed transaction to the blockchain.
submitSignedTransaction :: ActiveWalletLayer IO
                        -> SignedTransaction
                        -> Handler (APIResponse Transaction)
submitSignedTransaction aw signedTx = liftIO $ do
    res <- liftIO $ (WalletLayer.submitSignedTx aw) signedTx
    case res of
        Left err -> throwM err
        Right (_, meta) -> txFromMeta aw WalletLayer.NewPaymentUnknownAccountId meta
